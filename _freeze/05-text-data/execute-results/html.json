{
  "hash": "f1e7195f7188043c2ca9aff1815b577b",
  "result": {
    "markdown": "# Prepare for Text Data {#sec-text_data}\n\n## Patterns and Regular Expressions (regexes)\n\n\n::: {.cell}\n\n:::\n\n\nShort for regular expressions, regex (pronounced reg-ex) is a language for describing patterns in strings.\n\nLike any language, regex will appear foreign and difficult to understand without constantly looking up definitions for symbols. A good dictionary is the regex cheat sheet; search for \"Regular Expressions\" in <https://www.rstudio.com/resources/cheatsheets/>. The important definitions are in the left and bottom boxes.\n\nWhy learn this language? When do you need a language for describing patterns in strings?\n\n## Motivation\n\nThe first definition under heading \"Character Classes\" in the [regex cheatsheet](https://rstudio.github.io/cheatsheets/regex.pdf) is\n\n```         \n[[:digit:]] or \\\\d  Digits; [0-9]\n```\n\nThis tells us that to represent digits in patterns, we can write `\"[[:digit:]]\"` or `\"\\\\d\"`.\n\nWhen do we need patterns? Let's say we want to make sure each row in the `date` column of our `df` has exactly 8 digits: 4 for the year, 2 for the month and 2 for the day. We cannot write the 8 digits directly, we need to represent them abstractly; that is the responsibility of patterns.\n\nThe pattern for digits is `\"[[:digit:]]\"` or `\"\\\\d\"`. Now we need a pattern for \"8 times\". We also cannot simply write 8, as we want to avoid representing the character 8. We now look for the abstract pattern representing \"times\": or, in other words, \"occurences\". On the bottom right, this pattern will be under the grey heading \"Quantifiers\".\n\nThe 4th definition is\n\n```         \n{n}  Matches exactly n times\n```\n\nThis tells us that to match 8 times, we can write `\"{8}\"`.\n\nCombining what we learned about digits, we now write a pattern for digits 8 times: `\"\\\\d{8}\"`.\n\nBefore using this pattern, let us try to understand each symbol. The `\\\\` are needed to make sure that the pattern is not for the character \"d\" itself. Similarly, the `{` and `}` are needed to make sure that the pattern is not for the number \"8\" itself.\n\nIf we try to use our pattern to filter for dates with 8 digits, we get the following\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> filter(date |> str_detect(\"\\\\d{8}\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 0 × 9\n# ℹ 9 variables: source <chr>, country <chr>, date <chr>, file_type <chr>,\n#   continent <chr>, year <dbl>, lifeExp <chr>, pop <chr>, gdpPercap <chr>\n```\n:::\n:::\n\n\n0 rows in our date column have digits exactly 8 times. How can that be?\n\nLooking back at our date column, what do we see?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 24 × 9\n   source    country     date  file_type continent  year lifeExp pop   gdpPercap\n   <chr>     <chr>       <chr> <chr>     <chr>     <dbl> <chr>   <chr> <chr>    \n 1 gapminder Afghanistan 2022… csv       Asia       1952 28.801  8425… 779.4453…\n 2 gapminder Afghanistan 2022… csv       Asia       1957 30.332  9240… 820.8530…\n 3 gapminder Afghanistan 2022… csv       Asia       1962 31.997  1026… 853.10071\n 4 gapminder Afghanistan 2022… csv       Asia       1967 34.02   1153… 836.1971…\n 5 gapminder Afghanistan 2022… csv       Asia       1972 36.088  1307… 739.9811…\n 6 gapminder Afghanistan 2022… csv       Asia       1977 38.438  1488… 786.11336\n 7 gapminder Afghanistan 2022… csv       Asia       1982 39.854  1288… 978.0114…\n 8 gapminder Afghanistan 2022… csv       Asia       1987 40.822  1386… 852.3959…\n 9 gapminder Afghanistan 2022… csv       Asia       1992 41.674  1631… 649.3413…\n10 gapminder Afghanistan 2022… csv       Asia       1997 41.763  2222… 635.3413…\n# ℹ 14 more rows\n```\n:::\n:::\n\n\n`date` has 4 digits, followed by a *hyphen*, followed by 2 digits, followed by a *hyphen*, followed by 2 digits. Our pattern simply represents 8 digits, one after the other with nothing in between.\n\nIf we alter our pattern to `\"\\\\d{4}-\\\\d{2}-\\\\d{2}\"`, we get the expected result:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> filter(date |> str_detect(\"\\\\d{4}-\\\\d{2}-\\\\d{2}\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 24 × 9\n   source    country     date  file_type continent  year lifeExp pop   gdpPercap\n   <chr>     <chr>       <chr> <chr>     <chr>     <dbl> <chr>   <chr> <chr>    \n 1 gapminder Afghanistan 2022… csv       Asia       1952 28.801  8425… 779.4453…\n 2 gapminder Afghanistan 2022… csv       Asia       1957 30.332  9240… 820.8530…\n 3 gapminder Afghanistan 2022… csv       Asia       1962 31.997  1026… 853.10071\n 4 gapminder Afghanistan 2022… csv       Asia       1967 34.02   1153… 836.1971…\n 5 gapminder Afghanistan 2022… csv       Asia       1972 36.088  1307… 739.9811…\n 6 gapminder Afghanistan 2022… csv       Asia       1977 38.438  1488… 786.11336\n 7 gapminder Afghanistan 2022… csv       Asia       1982 39.854  1288… 978.0114…\n 8 gapminder Afghanistan 2022… csv       Asia       1987 40.822  1386… 852.3959…\n 9 gapminder Afghanistan 2022… csv       Asia       1992 41.674  1631… 649.3413…\n10 gapminder Afghanistan 2022… csv       Asia       1997 41.763  2222… 635.3413…\n# ℹ 14 more rows\n```\n:::\n:::\n\n\nNow we not only checked that each row in `date` has 8 digits, but that theses digits are separated by hyphens in a XXXX-XX-XX format.\n\nWe still have not confirmed that the `date` column is in YYYY-MM-DD format (year-month-day format). This is unfortunately impossible for some cases. We cannot determine whether 02-04 is February 4nd or April 2nd unless we know whether the date was entered as MM-DD or DD-MM. Fortunately we can check cases where the day is greater than the 12th. We do so by checking whether the month in YYYY-MM-DD is between 01 and 12.\n\nTo do so we will adjust our pattern slightly so that month becomes a reference. To make a reference in a pattern, we surround the part we want to reference with round brackets: `(` and `)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npattern <- \"\\\\d{4}-(\\\\d{2})-\\\\d{2}\"\n```\n:::\n\n\nTo extract the reference, we must refer to it by number. We need to use a number, as it is possible to have more than one reference group. Again we use `\\\\` to make sure the pattern is not for the number \"1\" itself.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreplacement <- \"\\\\1\"\n```\n:::\n\n\nWe now use our pattern and replacement in the function `str_replace()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonth <- \"2022-13-01\" |> str_replace(pattern, replacement)\nmonth\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"13\"\n```\n:::\n:::\n\n\nWe can treat this as numeric.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonth |> as.numeric()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13\n```\n:::\n:::\n\n\nAnd then check whether it is above 12.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonth |> as.numeric() > 12\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nTo do this for every row of our data frame, we will create a month column, treat it as numeric, and filter by values greater than 12:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- df |> \n  mutate(month = date |> str_replace(\"\\\\d{4}-(\\\\d{2})-\\\\d{2}\", \"\\\\1\") |> as.numeric())\n\ndf |> filter(month > 12)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 0 × 10\n# ℹ 10 variables: source <chr>, country <chr>, date <chr>, file_type <chr>,\n#   continent <chr>, year <dbl>, lifeExp <chr>, pop <chr>, gdpPercap <chr>,\n#   month <dbl>\n```\n:::\n:::\n\n\nThere are no rows where month is greater than 12.\n\n## Understanding Representations\n\nIf data contains characters like quotes and backslashes, R cannot directly represent them in a string. We can try to write each of these directly in a string and see what happens.\n\n*Quotes:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"\"\"\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in parse(text = input): <text>:1:3: unexpected INCOMPLETE_STRING\n1: \"\"\"\n      ^\n```\n:::\n:::\n\n\nR reads the first two set of quotes `\"\"` as an empty string, and considers the third set to be starting a second, incomplete string.\n\n*Backslash:*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"\\\"\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in parse(text = input): <text>:1:1: unexpected INCOMPLETE_STRING\n1: \"\\\"\n    ^\n```\n:::\n:::\n\n\nThe backslash has a special behaviour, preventing the second `\"` from ending the string.\n\n*Solution:*\n\nSince R cannot represent quotes and backslash directly, it must instead represent them indirectly with special sequences of characters. For quotes, the representative sequence in R is `\\\"`. For a backslash, the sequence is `\\\\`.\n\nWhen we place these sequences in strings, the output is not an error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"\\\"\" \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"\\\"\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\"\\\\\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"\\\\\"\n```\n:::\n:::\n\n\nFurther, we can see what each sequence represents by using the function `writeLines()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"\\\"\" |> writeLines()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\"\\\\\" |> writeLines()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\\\n```\n:::\n:::\n\n\nSequences `\\\"` and `\\\\` start with a backslash because a backslash has a specific behaviour: it prevents the normal interpretation of the next character. The backslash in the string`\"\\\"\"` prevents the second quotes from being interpreted as the end of the string. As for the string `\"\\\\\"`, because of the first backslash the second backslash is not normally interpreted as \"preventing the normal interpretation of the next character\". Yes you will likely have to re-read that.\n\n`\\\"` and `\\\\` are called special characters. Special characters are called special because they hold a special property: they each represent *one* thing (a unique character that cannot be represented directly). `\\\"` represents quotes, and `\\\\` represents backslash. Scan the following list of special characters and what they represent.\n\n| Special Characters | Represents                       |\n|--------------------|----------------------------------|\n| \\\\n                | newline                          |\n| \\\\r                | carriage return                  |\n| \\\\t                | tab                              |\n| \\\\b                | backspace                        |\n| \\\\a                | alert (bell)                     |\n| \\\\f                | form feed                        |\n| \\\\v                | vertical tab                     |\n| \\\\\\\\               | backslash \\\\                     |\n| \\\\'                | ASCII apostrophe '               |\n| \\\\\"                | ASCII quotation mark \"           |\n| \\\\\\`               | ASCII grave accent (backtick) \\` |\n\nNotice how each has *one* backslash except for the case of `\\\\`. Again these special characters represent *one* thing. Representations of *multiple* things, however, have *multiple* backslashes (two to be exact). As an example, `\\\\d` represents multiple things because it represents any of the multiple digits from 0 to 9.\n\n`\\\\` is a strange case. It is the only special character representing *one* thing with *multiple* backslashes. It is an even stranger case when used inside a pattern. We get an error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npattern <- \"\\\\\"\n\"\\\\\" |> str_detect(\"\\\\\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in stri_detect_regex(string, pattern, negate = negate, opts_regex = opts(pattern)): Unrecognized backslash escape sequence in pattern. (U_REGEX_BAD_ESCAPE_SEQUENCE, context=`\\`)\n```\n:::\n:::\n\n\nAn error does not happen with any of the other special characters used in this way. The reason is that `\\\\` is already used in patterns like `\\\\d`. If the pattern to match the string `\"\\\\\"` was simply `\"\\\\\"`, representations like `\\\\d` would lose their meaning. For example, instead of matching digits, `\\\\d` would just match `\\\\` followed by a `d`.\n\nTo match the string `\"\\\\\"` we must use the pattern `\"\\\\\\\\\"`. To remember this, consider how R views four backslashes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"\\\\\\\\\" |> writeLines()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\\\\\n```\n:::\n:::\n\n\n<!-- `\\d` is not a *string* escape sequence, but it is a *regex* (pattern-matching) escape sequence. For R to use `\\d`, we need R to view a pattern string as `\\d`. Since `\\` is a metacharacter whose behaviour is to escape the behaviour of the next character, we can use `\\` to escape itself. the behaviour of the `\\` before the `d`. This prevents the error of a non-existent string escape sequence, `\\\\d` is essentially an escaped `\\d` and R views `\\\\d` as `\\d`: -->\n\n<!-- ```{r} -->\n\n<!-- pattern_string <- \"\\\\d\" -->\n\n<!-- pattern_string |> writeLines -->\n\n<!-- \"4\" |> str_detect(pattern_string) -->\n\n<!-- ``` -->\n\n<!-- Similarly with the reference group `\\\\1`, using `\"\\\\1\"` allows R's regex engine to see the escape sequence `\\\\1`. -->\n\n<!-- The pattern `\\n` on the other hand, does not need two `\\`. If we used two inside a pattern, R would see the escape sequence `\\n`. -->\n\n<!-- R sees an escape sequence. With `\\n`, R does not see an escape sequence. -->\n\n<!-- ```{r} -->\n\n<!-- \"\\n\" |> writeLines -->\n\n<!-- \"\\`\" |> writeLines -->\n\n<!-- \"\\\\\\n\" |> writeLines -->\n\n<!-- \"\\\\ -->\n\n<!-- \" -->\n\n<!-- \"\\\\n\" |> writeLines -->\n\n<!-- \"\\\\\\n\" |> str_detect(\"\\\\\\n\") -->\n\n<!-- ``` -->\n\n<!-- This escape sequence represents a new line. Hence it will match a new line just like `\\n`. -->\n\n<!-- With three slashes, R sees a slash and a new line. -->\n\n<!-- ```{r} -->\n\n<!-- \"\\\\\\n\" |> writeLines -->\n\n<!-- ``` -->\n\n<!-- From now on I will use these definitions: -->\n\n<!-- 1. `\\` is the metacharacter slash -->\n\n<!-- 2. \\\\ is the literal slash -->\n\n<!-- If data contains a \\\\ like in the name \"Adam \\\\Sadowski\", R will represent it as `\"Adam \\\\Sadowski\"`. This is so that the \\\\ in \"Adam \\\\Sadowski\" is literal rather than symbolic. We can see what happens when we try to print a version with only one `\\`: -->\n\n<!-- ```{r error = TRUE} -->\n\n<!-- \"Adam \\Sadowski\" -->\n\n<!-- ``` -->\n\n<!-- This error occurs because  -->\n\n<!-- 1. We told R that we want `\\S`, which is called an escape (specifically, an escaped S), rather than a literal \\\\ followed by a literal S.  -->\n\n<!-- 2. An escaped S is not recognized.  -->\n\n<!-- There are only a few escaped letters that will be recognized by R. The letters are n, r, t, v and f. For example -->\n\n<!-- ```{r} -->\n\n<!-- \"Adam \\nadowski\" -->\n\n<!-- ``` -->\n\n<!-- prints just fine. Since `\\n` represents a new line, the string here represents literally  -->\n\n<!-- \"Adam \\n adowski\" -->\n\n<!-- These escaped letters can be found in the Special Metacharacters section of the cheatsheet. -->\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}